#!/usr/bin/env bash
set -euo pipefail

# GlimpseMRI full build on Jetson (CPU + GPU always)
# Builds in order:
#   1) dicom_io_lib
#   2) engine (CUDA ON)
#   3) gui
#
# Works with either CMake or qmake projects (auto-detect per module).
# Produces logs under ./build_logs/

ts() { date +"%Y-%m-%d %H:%M:%S"; }
log() { echo "[$(ts)][DBG] $*"; }
die() { echo "[$(ts)][ERR] $*" >&2; exit 1; }

CLEAN=0
BUILD_TYPE="Release"
RUN_TESTS=0
JOBS="$(nproc)"
VERBOSE=0

usage() {
  echo "Usage: $0 [--clean] [--debug] [--tests] [--jobs N] [--verbose] [--install-desktop]"
  echo "  --clean   : remove build dirs before building"
  echo "  --debug   : Debug build (default Release)"
  echo "  --tests   : run ctest when available"
  echo "  --jobs N  : parallel jobs (default nproc)"
  echo "  --verbose : print extra info"
  echo "  --install-desktop : create Desktop/app-menu launcher after successful build"
}

# Parse args
while [[ $# -gt 0 ]]; do
  case "$1" in
    --clean) CLEAN=1; shift ;;
    --debug) BUILD_TYPE="Debug"; shift ;;
    --tests) RUN_TESTS=1; shift ;;
    --jobs) JOBS="${2:-$JOBS}"; shift 2 ;;
    --verbose) VERBOSE=1; shift ;;
    --install-desktop) INSTALL_DESKTOP=1; shift ;;
    -h|--help) usage; exit 0 ;;
    *) die "Unknown arg: $1" ;;
  esac
done

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Optional: install desktop launcher after successful build (explicit opt-in)
INSTALL_DESKTOP="${INSTALL_DESKTOP:-0}"
DESKTOP_ICON_SCRIPT="${ROOT}/gui/scripts/install_desktop_icon.sh"
LOG_DIR="${ROOT}/build_logs"
mkdir -p "${LOG_DIR}"
LOG_FILE="${LOG_DIR}/build_$(date +"%Y%m%d_%H%M%S")_${BUILD_TYPE}.log"

# Log all output
exec > >(tee -a "${LOG_FILE}") 2>&1

log "ROOT=${ROOT}"
log "BUILD_TYPE=${BUILD_TYPE}"
log "JOBS=${JOBS}"
log "CLEAN=${CLEAN}"
log "RUN_TESTS=${RUN_TESTS}"
log "VERBOSE=${VERBOSE}"
log "INSTALL_DESKTOP=${INSTALL_DESKTOP}"
log "DESKTOP_ICON_SCRIPT=${DESKTOP_ICON_SCRIPT}"
log "ARCH=$(uname -m)"
log "KERNEL=$(uname -r)"
log "GIT_HEAD=$(git rev-parse --short HEAD || echo 'N/A')"
log "GIT_STATUS:"
git status -sb || true

# Pull submodules if any
log "Updating submodules (if any)..."
git submodule update --init --recursive || true

ensure_cmd() {
  local c="$1"
  command -v "$c" >/dev/null 2>&1 || die "Missing command: $c"
}

maybe_clean_dir() {
  local d="$1"
  if [[ "${CLEAN}" -eq 1 ]]; then
    log "Cleaning build dir: ${d}"
    rm -rf "${d}"
  fi
}

detect_build_system() {
  local dir="$1"
  if [[ -f "${dir}/CMakeLists.txt" ]]; then
    echo "cmake"
    return 0
  fi
  if find "${dir}" -maxdepth 2 -type f -name "*.pro" | grep -q .; then
    echo "qmake"
    return 0
  fi
  echo "none"
}

pick_qmake() {
  if command -v qmake6 >/dev/null 2>&1; then echo "qmake6"; return 0; fi
  if command -v qt6-qmake >/dev/null 2>&1; then echo "qt6-qmake"; return 0; fi
  if command -v qmake >/dev/null 2>&1; then echo "qmake"; return 0; fi
  echo ""
}

pick_generator() {
  if command -v ninja >/dev/null 2>&1; then
    echo "Ninja"
  else
    echo "Unix Makefiles"
  fi
}

# Detect CUDA arch on Jetson model (best-effort)
detect_cuda_arch() {
  local model=""
  if [[ -r /proc/device-tree/model ]]; then
    model="$(tr -d '\0' </proc/device-tree/model || true)"
  fi
  log "Jetson model: ${model:-unknown}"

  # Best-effort mapping:
  # Orin (Ampere) -> SM 87
  # Xavier (Volta) -> SM 72
  # Nano/TX1/TX2 (Maxwell/Pascal) -> varies; default 53/62; we pick 62 as safer
  if echo "$model" | grep -qi "Orin"; then
    echo "87"
    return 0
  fi
  if echo "$model" | grep -qi "Xavier"; then
    echo "72"
    return 0
  fi
  # fallback
  echo "87"
}

build_cmake() {
  local name="$1"
  local src="$2"
  local bld="$3"
  shift 3
  local extra_args=("$@")

  ensure_cmd cmake
  local gen
  gen="$(pick_generator)"
  log "CMake generator: ${gen}"

  maybe_clean_dir "${bld}"
  mkdir -p "${bld}"

  log "Configuring ${name} (CMake, ${BUILD_TYPE})"
  log "Extra args: ${extra_args[*]:-<none>}"

  cmake -S "${src}" -B "${bld}" -G "${gen}" \
    -DCMAKE_BUILD_TYPE="${BUILD_TYPE}" \
    "${extra_args[@]}"

  log "Building ${name}"
  cmake --build "${bld}" -j "${JOBS}"

  if [[ "${RUN_TESTS}" -eq 1 ]]; then
    if [[ -f "${bld}/CTestTestfile.cmake" ]] || [[ -d "${bld}/Testing" ]]; then
      log "Running ctest for ${name}"
      ( cd "${bld}" && ctest --output-on-failure -j "${JOBS}" )
    else
      log "No tests detected for ${name}, skipping."
    fi
  fi

  log "Artifacts (${name}):"
  find "${bld}" -maxdepth 4 -type f \( -executable -o -name "*.so" -o -name "*.a" \) -print || true
}

build_qmake() {
  local name="$1"
  local pro="$2"
  local bld="$3"
  shift 3
  local extra_args=("$@")

  ensure_cmd make
  local qmake_bin
  qmake_bin="$(pick_qmake)"
  [[ -n "${qmake_bin}" ]] || die "No qmake found (qmake6/qt6-qmake/qmake). Run ./prerequisites.sh"

  maybe_clean_dir "${bld}"
  mkdir -p "${bld}"

  local cfg="release"
  [[ "${BUILD_TYPE}" == "Debug" ]] && cfg="debug"

  log "Configuring ${name} (qmake=${qmake_bin}, cfg=${cfg}) pro=${pro}"
  (
    cd "${bld}"
    "${qmake_bin}" "${pro}" "CONFIG+=${cfg}" "${extra_args[@]}"
    log "Building ${name} (make -j ${JOBS})"
    make -j "${JOBS}"
  )

  log "Artifacts (${name}):"
  find "${bld}" -maxdepth 4 -type f \( -executable -o -name "*.so" -o -name "*.a" \) -print || true
}

build_module() {
  local name="$1"
  local dir="$2"
  local bld="$3"
  shift 3
  local extra_args=("$@")

  [[ -d "${dir}" ]] || die "Missing dir: ${dir}"

  log "----------------------------------------"
  log "BUILD MODULE: ${name}"
  log "DIR=${dir}"
  log "BLD=${bld}"
  log "----------------------------------------"

  local sys
  sys="$(detect_build_system "${dir}")"
  log "Detected build system: ${sys}"

  if [[ "${sys}" == "cmake" ]]; then
    build_cmake "${name}" "${dir}" "${bld}" "${extra_args[@]}"
    return 0
  fi

  if [[ "${sys}" == "qmake" ]]; then
    local pro
    pro="$(find "${dir}" -maxdepth 2 -type f -name "*.pro" | head -n 1 || true)"
    [[ -n "${pro}" ]] || die "qmake build detected but no .pro found in ${dir}"
    if [[ "${name}" == "engine" ]]; then
      build_qmake "${name}" "${pro}" "${bld}" "CONFIG+=with_cuda"
    else
      build_qmake "${name}" "${pro}" "${bld}"
    fi
    return 0
  fi

  die "No supported build system found in ${dir} (need CMakeLists.txt or *.pro)"
}

# --- CUDA enable flags (best effort; harmless if unused by your project) ---
CUDA_NVCC="/usr/local/cuda/bin/nvcc"
CUDA_ARCH="$(detect_cuda_arch)"
log "CUDA_NVCC=${CUDA_NVCC} (exists? $(test -x "${CUDA_NVCC}" && echo yes || echo no))"
log "CUDA_ARCH=${CUDA_ARCH}"

# Common CMake knobs used in many projects; extra vars usually don't break anything.
ENGINE_CUDA_ARGS=(
  "-DCMAKE_CUDA_COMPILER=${CUDA_NVCC}"
  "-DCMAKE_CUDA_ARCHITECTURES=${CUDA_ARCH}"
  "-DENABLE_CUDA=ON"
  "-DUSE_CUDA=ON"
  "-DGLIMPSE_ENABLE_CUDA=ON"
)

# Build order: libs -> engine -> gui
build_module "dicom_io_lib" "${ROOT}/dicom_io_lib" "${ROOT}/build_dicom_${BUILD_TYPE}"
ENGINE_SYS="$(detect_build_system "${ROOT}/engine")"
if [[ "${ENGINE_SYS}" == "cmake" ]]; then
  build_module "engine"       "${ROOT}/engine"       "${ROOT}/build_engine_${BUILD_TYPE}" "${ENGINE_CUDA_ARGS[@]}"
else
  build_module "engine"       "${ROOT}/engine"       "${ROOT}/build_engine_${BUILD_TYPE}"
fi
build_module "gui"          "${ROOT}/gui"          "${ROOT}/build_gui_${BUILD_TYPE}"

log "========================================"
log "ALL BUILDS OK"
log "Log saved to: ${LOG_FILE}"
log "========================================"

log "GUI executable candidates:"
find "${ROOT}/build_gui_${BUILD_TYPE}" -maxdepth 5 -type f -executable -print || true

log "NOTE: If GUI fails at runtime due to missing engine .so, try:"
log "  export LD_LIBRARY_PATH=${ROOT}/build_engine_${BUILD_TYPE}:\$LD_LIBRARY_PATH"
log "  ./build_gui_${BUILD_TYPE}/<your_gui_binary>"

# ------------------------------------------------------------
# Optional: create a Desktop launcher (explicit opt-in)
# ------------------------------------------------------------
if [[ "${INSTALL_DESKTOP}" == "1" ]]; then
  log "Installing desktop launcher..."
  log "DESKTOP_ICON_SCRIPT=${DESKTOP_ICON_SCRIPT}"

  if [[ -x "${DESKTOP_ICON_SCRIPT}" ]]; then
    "${DESKTOP_ICON_SCRIPT}"
    log "Desktop launcher install OK."
    log "NOTE: You may need to right-click the Desktop icon and choose 'Allow Launching' once."
  else
    die "Desktop icon script not found or not executable: ${DESKTOP_ICON_SCRIPT}"
  fi
fi